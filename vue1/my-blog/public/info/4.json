{
    "title": "我的vue仓库不一定要再是vuex",
    "date": "2020-5-06 13:27",
    "id": 0,
    "author": "黄力豪",
    "connect": [
        "有vuex的state , getters, mutations ,actions ,modules\n      会将所有文件的代码分享出来,看不懂的安装vue脚手架 , 然后将这些代码贴进去 ,\n      然后在main.js文件中引入我写的index.js,然后使用就行\n      import store from './store'\n\n      new Vue({\n        el: '#app',\n        router,\n        store,\n        components: { App },\n        template: '<App/>'\n      })\n      我这里是将index.js放在store文件夹下面\n\nvuex.js文件代码及解析,就是源码\nlet Vue //  声明Vue变量\n\n//  先看这里 第一步 \n\nconst install = _Vue => { //在main.js文件中使用了Vue.use(Vuex)  可以使用安装函数 . 函数参数为Vue实例\n    Vue = _Vue  //将Vue实例赋值到全局变量\n    Vue.mixin({\n        beforeCreate() {  // 为每一个组件的beforeCreate生命周期添加this.$store\n            if (this.$options && this.$options.store) {\n\n                // this.$options 基本等于 main.js中 new Vue({\n                //     el: '#app',\n                //     router,\n                //     store,\n                //     components: { App },\n                //     template: '<App/>'\n                //   })里面的参数\n\n                // 所以 this.$options.store = 类 Store的实例\n\n                this.$store = this.$options.store   //将 this.$options.store 的值赋给 this.$store \n            }\n            else {\n                this.$store = this.$parent && this.$parent.$store\n                // 如果当前组键不存在  this.$options.store 则拿父亲的$store,这样保证所有的this.$store都是同一个store ,也就是类Store的实例\n\n            }\n        }\n    })\n}\n\nconst installCollection = (store, state, path, rootModules) => {\n\n    if (path.length > 0) {\n\n        // 和上面基本类似  \n\n        // 主要作用是将 state 由 {name:10}变为\n        // {\n        //     name: 10, a: {\n        //         x: 1,\n        //         c: { a:8}\n        //     },\n        //     b{}\n        // }\n\n        let parent = path.slice(0, -1).reduce((state, current) => {\n            return state[current]\n        }, state)\n\n        Vue.set(parent, [path[path.length - 1]], rootModules.state);\n\n    }\n\n    let getters = rootModules._raw.getters\n\n    // 为你传过来的getters\n\n    if (getters) {\n        Object.keys(getters).forEach(getter => {\n            // 将所有的getter 属性 劫持在最外层的getters 上 也就是this.$store.getters\n            Object.defineProperty(store.getters, getter, {\n                get: () => {\n                    return getters[getter](rootModules.state)\n                    //getters的参数为当前state\n                }\n            })\n        })\n    }\n\n    let mutations = rootModules._raw.mutations\n\n    if (mutations) {\n\n        // 为你传过来的mutations\n        Object.keys(mutations).forEach(mutation => {\n\n\n            let arr = store.mutations[mutation] || (store.mutations[mutation] = [])\n            \n            // 将this.$store.mutations转化成 {\n            //     syncadd:[],\n            //     asyncsub:[]\n            // }格式\n            // 因为执行 如  this.$store.commit('syncAdd', 10);代码 会将所有模块中的syncAdd执行\n\n            arr.push((...parmas) => {\n                // 将需要执行的函数放入队列中\n                mutations[mutation].call(store, rootModules.state, ...parmas)\n            })\n        })\n    }\n\n    let actions = rootModules._raw.actions\n    // 为你传过来的actions\n    if (actions) {\n\n        //基本类似mutations ,只是actions的第一个参数为 Store实例 ,mutaions的第一个参数为state \n        Object.keys(actions).forEach(action => {\n\n            let arr = store.actions[action] || (store.actions[action] = [])\n\n            arr.push((...parmas) => {\n                actions[action].call(store, store, ...parmas)\n            })\n        })\n    }\n\n\n    if (rootModules._children) {\n        Object.keys(rootModules._children).forEach(moduleName => {\n            installCollection(store, state, path.concat(moduleName), rootModules._children[moduleName])\n        })\n    }\n}\n\n// 第三步\n\nclass ModelesCollection {\n\n    //    主要目的是整合module,将module放入_children中,方便递归.\n\n    //    如 原仓库 :{\n    //        state:{x:30},\n    //        getter:{},\n    //        ....,\n    //        module:{\n    //            a:{\n    //             state:{ y:50},\n    //             getter:{},\n    //             ....\n    //            },\n    //            b:{\n    //             state:{},\n    //             getter:{},\n    //             ....\n    //            }\n    //        }\n    //    }\n\n    // 将数据整合成如下格式:\n\n    // _root = {\n    //     _children: {\n    //         a: {\n    //             _children: {},\n    //             state: {y:50},\n    //             _row: {}\n    //         },\n    //         b: {\n    //             _children: {},\n    //             state: {},\n    //             _row: {}\n    //         }\n    //     },\n    //     _raw:{},  // _row 就是当前的模块仓库 ,如最外层的_raw就是this.$store\n    //     state:{x:30}  \n    // }\n\n\n    // }\n\n    constructor(options) {\n        this.register([], options)  // 调用 register 函数 ,options 如第一次调用 opts 是 new Store 传过来的参数,也就是 index.js中 new Vuex.Store的参数\n    }\n    register(path, rootModules) {\n        let newModules = {\n            _raw: rootModules,\n            state: rootModules.state || {},\n            _children: {}\n        }\n        if (path.length === 0) {   //  步骤 :3_1  当前的仓库没有父级,让this._root 为newModules   \n            this._root = newModules\n        } else {\n            let parent = path.slice(0, -1).reduce((root, current) => {\n                return root._children[current]\n            }, this._root)  //获取倒数第二个模块,让其成为父亲,如果长度为1  则父亲为  this._root\n            //  步骤 :3_3 \n            // parent 分别为 this._root , this._root, a模块\n            parent._children[path[path.length - 1]] = newModules\n        }\n        if (rootModules.modules) {   //  步骤 :3_2   \n            Object.keys(rootModules.modules).forEach(moduleName => {\n                this.register(path.concat(moduleName), rootModules.modules[moduleName])\n                // 联合index 中的数据 \n                // 此时 path.concat(moduleName) 分别为 ['a'],['b'],['a','c']\n                // rootModules.modules[moduleName] 分别为a模板中的所有数据,b模块中的所有数据,c模块中的所有数据\n            })\n        }\n    }\n}\n\n// 第二步\n\n// 上面this.$store 就是这个类的实例\n\nclass Store {\n    constructor(opts) {  //opts 是 new Store 传过来的参数,也就是 index.js中 new Vuex.Store的参数\n        this._vm = new Vue({\n            data() {\n                return {\n                    state: opts.state\n                }\n            }\n        })\n        // 将state中的数据放入vue中的data中\n\n        this.getters = {}  //创建一个空的getters 对象\n        this.mutations = {} //创建一个空的mutations 对象\n        this.actions = {}  // 创建一个空的actions对象\n        this.modules = new ModelesCollection(opts)  //跳转到第三步\n        installCollection(this, this.state, [], this.modules._root)\n        // 跳转到第四步 参数分别为 Store的实例 , 就是你使用的this.$store , 最外层的 state , 路径  空数组 代表无父亲 为 root , 如[a,b,c]则,a的父亲为root,b的父亲为a,c的父亲为b\n        //第四个参数 就是这类数据\n        //  {\n        //     _raw: rootModules,\n        //     state: rootModules.state || {},\n        //     _children: {}\n        // }\n    }\n\n    get state() {\n        return this._vm.state  //当读 this.$store.state 时触发 ,返回 opts.state ,也就是仓库中的state\n    }\n    commit = (type, ...parmas) => {\n        //执行所有type 类型的函数\n        this.mutations[type].forEach(fn => {\n            fn(...parmas)\n        })\n    }\n    dispatch = (type, ...parmas) => {\n\n        // 基本同 commit\n        \n        this.actions[type].forEach(fn => {\n            fn(...parmas)\n        })\n    }\n}\n\n\nexport default {\n    Store,\n    install\n}\nAPP.vue文件代码\n<template>\n  <div id='app'>\n    <div>{{this.$store.state.name}}</div>\n    <div>{{this.$store.getters.myage}}</div>\n    <div>{{this.$store.getters.y}}</div>\n    <div>{{this.$store.state.a.x}}</div>\n    <button @click='add'>+10</button>\n    <button @click='sub'>-10</button>\n\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  mounted() {\n    console.log(this.$store);\n    setTimeout(() => {\n      this.$store.state.name = 100;\n    }, 1000);\n  },\n  methods: {\n    add() {\n      this.$store.commit('syncAdd', 10);\n    },\n    sub() {\n      this.$store.dispatch('asyncSub', 10);\n    }\n  }\n};\n</script>\nindex.js 代码 就是仓库代码\nimport Vue from 'vue'\nimport Vuex from './vuex'\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: {\n        name: 10\n    },\n    getters: {\n        myage(state) {\n            return state.name + 10\n        }\n    },\n    mutations: {\n        syncAdd(state, parmas) {\n            state.name += parmas\n        },\n        syncsub(state, parmas) {\n            state.name -= parmas\n        }\n    },\n    actions: {\n        asyncSub({ commit, dispatch }, ...parmas) {\n            setTimeout(() => {\n                commit('syncsub', ...parmas)\n            }, 1000);\n        }\n    },\n    modules: {\n        a: {\n            state: {\n                x: 1,\n\n            },\n            getters: {\n                y(state) {\n                    return state.x + 3\n                }\n            },\n            modules: {\n                c: {\n                    state: {\n                        a:8\n                    }\n                }\n            },\n            mutations: {\n                syncAdd(state, parmas) {\n                    console.log(123);\n                    \n                }\n                \n            },\n        },\n        b: {}\n    }\n})\n\n      "
    ],
    "imgs": []
}